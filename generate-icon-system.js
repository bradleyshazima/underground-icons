// generate-icon-system.js
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";

// ============================================================
// --- Setup ---
// ============================================================
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ============================================================
// --- CONFIGURATION (no more terminal args) ---
// ============================================================
const config = {
  setName: "Iconamoon", // e.g. 'Iconsax'
  prefix: "Im",       // e.g. 'Is'
  style: "outline",      // e.g. 'fill', 'outline', 'duotone'
  inputDir: "src/icons/iconamoon/outline", // input directory
};
// ============================================================

// Derive directories
const { setName, prefix, style, inputDir } = config;
const JSX_ICONS_DIR = path.resolve(inputDir, "jsx");
const SVG_DIR = path.resolve(inputDir, "svg");

// Output file: unique per icon set + style
const OUTPUT_DATA_FILE = path.join(
  __dirname,
  "src",
  "data",
  `iconData-${setName.toLowerCase()}-${style.toLowerCase()}.js`
);

console.log(`\n‚öôÔ∏è  Building Icon Data for:
  ‚Ä¢ Set: ${setName}
  ‚Ä¢ Prefix: ${prefix}
  ‚Ä¢ Style: ${style}
  ‚Ä¢ Input: ${inputDir}
  ‚Ä¢ Output: ${OUTPUT_DATA_FILE}\n`);

// ============================================================
// --- Helpers ---
// ============================================================

async function sanitizeFileNames(directory) {
  try {
    const files = await fs.readdir(directory);
    for (const filename of files) {
      if (filename.includes("-")) {
        const oldBase = path.basename(filename, path.extname(filename));
        const newBase = oldBase.split("-")[0];
        const newFilename = newBase + path.extname(filename);

        if (filename !== newFilename) {
          const oldPath = path.join(directory, filename);
          const newPath = path.join(directory, newFilename);
          await fs.rename(oldPath, newPath);

          const content = await fs.readFile(newPath, "utf-8");
          const updated = content.replace(
            new RegExp(`export const ${oldBase}\\b`),
            `export const ${newBase}`
          );
          await fs.writeFile(newPath, updated, "utf-8");
        }
      }
    }
  } catch {
    // ignore
  }
}

function pascalToKebab(str) {
  return str
    .replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2")
    .toLowerCase();
}

// ============================================================
// --- Main ---
// ============================================================

async function generateIconDataFile() {
  try {
    await fs.access(JSX_ICONS_DIR);
    await fs.access(SVG_DIR);
  } catch {
    console.error(`‚ùå Directories not found: ${JSX_ICONS_DIR} or ${SVG_DIR}`);
    return;
  }

  console.log("üöÄ Starting build...");

  await sanitizeFileNames(JSX_ICONS_DIR);
  await sanitizeFileNames(SVG_DIR);

  const allJsxFiles = await fs.readdir(JSX_ICONS_DIR);

  const imports = [];
  const iconSet = {
    name: setName,
    creator: "Dariush",
    socialLink: "https://www.figma.com/@dariush",
    prefix,
    style,
    icons: [],
  };
  const jsxContentMap = new Map();

  for (const file of allJsxFiles) {
    if (!file.endsWith(".jsx")) continue;
    const componentName = path.basename(file, ".jsx");
    const svgStringComponentName = `${componentName}Svg`;

    const jsxFilePath = path.join(JSX_ICONS_DIR, file);
    const jsxFileContent = await fs.readFile(jsxFilePath, "utf-8");
    jsxContentMap.set(componentName, jsxFileContent);

    imports.push(`import { ${componentName} } from '${path.relative(
      path.dirname(OUTPUT_DATA_FILE),
      path.join(JSX_ICONS_DIR, componentName)
    ).replace(/\\/g, "/")}';`);

    const svgRelativePath = path.relative(
      path.dirname(OUTPUT_DATA_FILE),
      path.join(SVG_DIR, `${componentName}.svg`)
    ).replace(/\\/g, "/");

    imports.push(`import ${svgStringComponentName} from '${svgRelativePath}?raw';`);

    const nameWithoutPrefix = componentName.substring(prefix.length);
    const kebabName = pascalToKebab(nameWithoutPrefix);

    function removePrefix(name) {
      return name.replace(/^(outline-|fill-|duotone-|-outline-|-fill-|-duotone-|-outline|-fill|-duotone)/, '');
    }

    iconSet.icons.push({
      name: removePrefix(kebabName),
      style,
      Component: `%%${componentName}%%`,
      svgString: `%%${svgStringComponentName}%%`,
      jsxString: `%%JSX_PLACEHOLDER_${componentName}%%`,
    });
  }

  const header = `// ‚ö†Ô∏è Auto-generated by generate-icon-system.js\n// ${setName} - ${style}\n\n`;
  let dataString = JSON.stringify([iconSet], null, 2);

  // Replace placeholders
  for (const [componentName, content] of jsxContentMap.entries()) {
    const placeholder = `"%%JSX_PLACEHOLDER_${componentName}%%"`;
    const escaped = content
      .replace(/\\/g, "\\\\")
      .replace(/`/g, "\\`")
      .replace(/\$/g, "\\$");
    dataString = dataString.replace(placeholder, `\`${escaped}\``);
  }

  dataString = dataString.replace(/"%%(.*?)%%"/g, "$1");

  const finalContent = `${header}${imports.join("\n")}\n\nexport const iconSets = ${dataString};\n`;
  await fs.writeFile(OUTPUT_DATA_FILE, finalContent, "utf-8");

  console.log(`‚úÖ Generated ${OUTPUT_DATA_FILE}`);
}

generateIconDataFile().catch(console.error);
